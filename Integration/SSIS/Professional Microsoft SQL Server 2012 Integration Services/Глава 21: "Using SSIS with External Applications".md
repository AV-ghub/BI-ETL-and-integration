Эта глава действительно выводит использование SSIS за пределы чисто ETL-процессов в среде SQL Server, показывая, как интегрировать мощь SSIS в различные прикладные сценарии.

---

### **Ключевые темы главы 21:**

#### **1. Вызов пакетов SSIS извне: методы и инструменты**
Это основа интеграции. Основные способы:
*   **Из .NET-приложений (C#, VB.NET):**
    *   **Использование пространства имен `Microsoft.SqlServer.ManagedDTS`** — это основной и наиболее гибкий способ. Позволяет не только запускать пакеты, но и программно настраивать параметры, переменные, обработчики событий, проверять логгирование.
    *   Пример: `Package pkg = app.LoadPackage(packageLocation, null); pkg.Execute();`
*   **Из скриптов и командной строки:**
    *   **Утилита `DTExec.exe`** — стандартный инструмент для запуска пакетов из командной строки, скриптов PowerShell (.ps1) или файлов пакетной обработки (.bat). Позволяет передавать параметры, настраивать соединения, задавать уровень логирования.
    *   **Утилита `DTExecUI.exe`** — ее графический интерфейс для построения командной строки.
*   **Из SQL Server Agent:** Классический способ для планирования, но технически это тоже "внешний" вызов.
*   **Из веб-приложений (ASP.NET):** Механизм тот же (.NET API или `DTExec`), но с важными оговорками:
    *   **Безопасность:** Учетная запись, под которой работает приложение (часто AppPool Identity), должна иметь права на файловую систему, доступ к пакетам и целевым БД.
    *   **Стабильность и время выполнения:** Длительные пакеты могут вызывать таймауты в HTTP-запросах. Рекомендуется асинхронный запуск (например, через очередь) или использование пакетов, которые быстро отчитываются о статусе.

#### **2. Программное управление и кастомизация пакетов**
Это не просто запуск "как есть". Через Managed DTS API можно:
*   **Динамически переопределять свойства:** Менять строки подключения (`ConnectionManager.ConnectionString`), задавать значения переменных (`Variables`), переназначать параметры (`Parameters`) прямо перед выполнением, в зависимости от контекста вызова из приложения.
*   **Перехват событий:** Подписываться на события пакета (OnError, OnWarning, OnPostExecute) для получения детальной информации о выполнении прямо в приложении.
*   **Валидация и проверка:** Вызывать метод `pkg.Validate()` для проверки готовности пакета к выполнению перед запуском.

#### **3. "Встраивание" Data Flow в приложения — главная "фишка" главы**
Здесь речь идет о компоненте **`PipelineComponent`** (или, точнее, об использовании движка потока данных вне дизайнера SSIS). Это сложная, но мощная возможность.
*   **Суть:** Вы можете программно создать "движок потока данных", добавить в него источники (Source), преобразования (Transformations) и приемники (Destination), и запустить этот мини-пакет прямо в памяти вашего .NET-приложения.
*   **Для чего это нужно?** Например, ваше desktop-приложение может получить файл от пользователя, мгновенно провалидировать его, преобразовать и загрузить в БД, используя всю мощь и скорость компонентов SSIS (например, преобразование "Сортировка" или "Уточняющий запрос"), без необходимости развертывать сам пакет .dtsx на сервере.
*   **Сложность:** Этот API низкоуровневый. Требуется много кода для создания компонентов, соединения их "путей" (Pipeline Paths) и настройки свойств. Это не для простых задач.

#### **4. Практические сценарии использования на собеседовании (ОЧЕНЬ важный раздел для обсуждения)**
*   **Консольное приложение-утилита:** Для администрирования или запуска специфичных пакетов по требованию.
*   **Веб-интерфейс для мониторинга и запуска ETL:** Пользователь (аналитик) через браузер может нажать кнопку "Обновить данные отчета", что вызовет соответствующий пакет SSIS.
*   **Desktop-приложение для загрузки данных:** Приложение бухгалтера принимает Excel-файл, а на фоне использует движок SSIS для его качественной загрузки в центральное хранилище.
*   **Интеграция в сложные бизнес-процессы:** Пакет SSIS может быть одним из шагов в workflow, управляемом Orchestrator или другим корпоративным приложением, которое вызывает его через .NET API.

---

### **Примерный вопрос с собеседования по этой теме:**

**"Представьте, что вам нужно дать возможность пользователям веб-портала запускать процесс обновления данных по нажатию кнопки. Процесс реализован в SSIS. Как вы это организуете? На что нужно обратить особое внимание?"**

**Что хочет услышать интервьюер:**
1.  **Архитектурное решение:** "Мы создадим отдельный веб-сервис (WCF/Web API) или фоновую задачу в веб-приложении, которая будет вызывать пакет через `ManagedDTS` или асинхронно запускать `DTExec`."
2.  **Безопасность:** "Учетная запись, под которой работает этот сервис, будет иметь минимально необходимые права на чтение пакета, запись в лог и доступ к целевым базам. Мы избегаем запуска от имени администратора."
3.  **Управление состоянием:** "Поскольку выполнение пакета может быть долгим, веб-интерфейс не будет ждать его завершения. Мы реализуем механизм очереди (например, через таблицу в БД или MSMQ). Сервис поместит задание в очередь и сразу вернет пользователю ID операции. Затем отдельный фоновый процесс (Windows Service) будет брать задания из очереди, выполнять пакет и обновлять статус. Пользователь сможет проверить статус по ID."
4.  **Обработка ошибок и логирование:** "Все события (ошибки, предупреждения) из пакета будут перехвачены в коде .NET и записаны в централизованный лог (базу данных или файл) с привязкой к ID операции, чтобы можно было отладить проблему."
5.  **Масштабируемость:** "Если запусков много, мы можем рассмотреть балансировку нагрузки между несколькими серверами-исполнителями, где установлена среда выполнения SSIS."

---

### **Следующий логичный шаг в книге:**
После интеграции на уровне данных, в **Главе 22 ("Understanding and Tuning the Data Flow Engine")** начинается углубление **внутрь "движка" SSIS**. Это переход от "как использовать" к "как это работает и как сделать быстрее". Там будут:
*   Архитектура Data Flow Task (буферы, компоненты, потоки).
*   Производительность: настройка буферов, понимание блокирующих, частично-блокирующих и неблокирующих преобразований.
*   Профилирование и поиск узких мест.
