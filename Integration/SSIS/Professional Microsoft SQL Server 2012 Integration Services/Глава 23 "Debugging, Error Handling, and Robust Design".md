Переходим к **вопросам отказоустойчивости, контроля качества и отладки** — тому, что превращает просто работающий пакет в **надежный промышленный ETL-процесс**.

---

### **Глава 23 "Debugging, Error Handling, and Robust Design"**

Эта глава отвечает на ключевые вопросы: **"Что делать, когда что-то пошло не так?"** и **"Как сделать так, чтобы сбои не были катастрофой?"**.

---

### **Ключевые темы главы:**

#### **1. Инструменты и методы отладки (Debugging)**
*   **Точки останова (Breakpoints):** Можно ставить не только на задачах, но и на **событиях отдельного компонента Data Flow** (OnPreExecute, OnPostExecute, OnError). Это позволяет "заморозить" выполнение и посмотреть состояние переменных, счетчиков строк в конкретный момент.
*   **Окна отладки в SSDT/BIDS:**
    *   **Locals / Watch:** Для отслеживания значений переменных во время выполнения.
    *   **Progress / Execution Results:** Отображает дерево выполнения, предупреждения, ошибки и информационные сообщения в реальном времени.
    *   **Data Viewers:** **Самый мощный инструмент для отладки Data Flow.** Позволяет подключить "окно просмотра" к пути между компонентами и видеть буферы данных, проходящие через это соединение, в реальном времени. Можно увидеть не только данные, но и "столбцы ошибок" (Error Column).
*   **Стратегия:** Отладка часто идет "от конца к началу". Если данные не доходят до Destination, ставьте Data Viewer на предыдущее соединение и так далее, пока не найдете компонент, который "глотает" или преобразует данные не так.

#### **2. Обработка ошибок на разных уровнях (Error Handling)**
Это многоуровневая система.

**А) Обработка ошибок в Data Flow (на уровне строк):**
*   **Концепция "Красного выхода" (Error Output):** Каждый компонент источника и преобразования в DFT имеет вкладку **Error Output**. Здесь можно определить политику поведения при ошибке для каждой колонки:
    *   **Fail Component** (Завершить с ошибкой) — поведение по умолчанию, пакет падает.
    *   **Ignore Failure** (Игнорировать) — "проглотить" ошибку, строка продолжит движение (значение в проблемном столбце станет NULL).
    *   **Redirect Row** (Перенаправить строку) — **НАИБОЛЕЕ ПОЛЕЗНАЯ ОПЦИЯ.** Проблемная строка отправляется на специальный **"красный" выход компонента**, откуда ее можно направить на отдельную обработку (например, в таблицу ошибок).
*   **Паттерн "Сбор плохих строк":** Источник → Настроить Redirect Row на ошибках → Подключить "красный выход" к отдельному Destination (например, "Stg_Errors"), а "зеленый" (успешный) выход — к основному потоку обработки.

**Б) Обработка ошибок в Control Flow (на уровне задач):**
*   **Соединители "При優先":** Исходящие из задачи соединители (зеленый — успех, красный — ошибка) позволяют строить ветвления логики: "Если задача выполнилась — иди дальше, если упала — выполни задачу-обработчик или отправь уведомление".
*   **Свойство `ForceExecutionResult`:** Может принудительно установить результат выполнения задачи как успешный (используется в сложных сценариях обработки).

**В) Обработка ошибок на уровне пакета (Event Handlers):**
*   **Обработчики событий (Event Handlers):** Это отдельные вкладки в дизайнере, где можно определить **целый вложенный пакет**, который выполнится при наступлении определенного события.
*   **Ключевые события:**
    *   **OnError:** Срабатывает при ЛЮБОЙ ошибке в любой точке пакета. Идеально для **централизованного логирования всех сбоев** и отправки алертов.
    *   **OnWarning, OnInformation:** Для менее критичных событий.
    *   **OnPostExecute, OnPreExecute:** Для служебного логирования (например, запись времени начала/окончания).
*   **Важно:** Обработчик `OnError` получает доступ к **системным переменным** (`System::ErrorCode`, `System::ErrorDescription`, `System::SourceName`), которые говорят, что именно сломалось.

#### **3. Логирование (Logging) и аудит**
*   **Встроенное логирование SSIS:** Позволяет записывать события выполнения (начало/конец задач, ошибки, предупреждения) в различные цели: **SQL Server (таблица `sysssislog`), текстовый файл, окно событий Windows, XML-файл**.
*   **Настройка:** Выбираете, какие события (`OnError`, `OnPostExecute` и т.д.) и для каких задач или всего пакета вы хотите логировать.
*   **Кастомное логирование:** Чаще используется паттерн, когда в начале пакета создается уникальный **ID выполнения (Batch ID)**, который передается через переменные и записывается во все целевые таблицы и таблицу ошибок. Это позволяет потом легко сшить весь процесс.

#### **4. Конфигурации и гибкость развертывания**
*   **Параметры (Parameters)** vs **Переменные (Variables):** Параметры (появились в SSIS 2012) предназначены для конфигурации пакета **извне** во время запуска (например, из каталога SSISDB или `DTExec`). Переменные используются для внутренней логики.
*   **Конфигурации (Package Configurations, SSIS 2008/2008R2):** Устаревший, но все еще встречающийся механизм для вынесения настроек (строк подключения, путей к файлам) во внешние XML-файлы, таблицы SQL или переменные среды. **На смену им пришли Parameters и Environments в Project Deployment Model.**
*   **Environments (в каталоге SSISDB):** Позволяют создавать наборы значений параметров (например, "Dev", "Test", "Prod") и назначать их проекту при запуске. **Лучшая практика для управления конфигурациями в разных средах.**

#### **5. Паттерны надежного дизайна (Robust Design Patterns)**
*   **Транзакции:** Можно настроить транзакцию на уровне всего пакета (`TransactionOption = Required`). Если любая задача завершится ошибкой, откатятся все изменения в БД в рамках этой транзакции. **Используется осторожно из-за риска блокировок.**
*   **Контрольные точки (Checkpoints):** Позволяют пакету, который упал, **перезапуститься с места последнего успешного выполнения**, а не с начала. Очень полезно для долгих пакетов. Сохраняет состояние переменных и отмечает завершенные задачи в файле `.checkpoint`.
*   **Рестартабельные пакеты:** Сочетание контроляльных точек и четкой логики (например, удаление/запись данных по диапазону дат) делает пакет устойчивым к сбоям.
*   **Валидация данных "на входе":** Лучше отклонить плохой файл целиком до начала загрузки, чем обрабатывать миллионы строк с редиректом ошибок. Используйте Script Task для предварительных проверок (существование файла, формат имени, непустоту).

---

### **Примерный вопрос с собеседованию:**

**"Опишите, как вы построите ETL-процесс для загрузки ежедневных транзакционных файлов от клиента, чтобы обеспечить надежность, отслеживаемость и возможность повторного запуска."**

**Что хочет услышать интервьюер (по пунктам из главы):**

1.  **Предварительная валидация (Script Task):** "Перед началом загрузки пакет проверяет наличие файла в заданной папке, его размер, корректность имени (с датой) и, возможно, базовую структуру (заголовки). Если проверка не пройдена — отправляется алерт, пакет завершается."
2.  **Транзакция и контрольные точки:** "Я настрою транзакцию на ключевой фазе загрузки (например, перемещение данных из стейджинга в основную таблицу) и включу **контрольные точки**, чтобы при сбое пакет перезапускался не с самого начала, а с момента после последней успешной транзакции."
3.  **Детальная обработка ошибок в Data Flow:** "В компоненте-источнике (Flat File Source) для критичных полей (ID, сумма, дата) настрою **Redirect Row на ошибках преобразования**. 'Плохие' строки пойдут в таблицу `Errors_Transactions` с пометкой даты загрузки и кода ошибки. 'Хорошие' — в стейджинг-таблицу."
4.  **Логирование и аудит:** "В начале пакета создается уникальный `LoadID`. Он и метка времени записываются в таблицу аудита `Log_ETL_Runs`. Все последующие шаги (сколько строк прочитано, загружено, отброшено) обновляют эту запись. В **обработчике событий `OnError`** все системные ошибки также пишутся в эту таблицу."
5.  **Уведомления:** "В обработчике `OnError` также настроена отправка email через задачу 'Send Mail' с ключевой информацией об ошибке (`System::ErrorDescription`) и `LoadID`."
6.  **Идемпотентность и повторный запуск:** "После успешной загрузки файл архивируется (перемещается в папку `\Archive`). Перед началом загрузки пакет проверяет, не обработан ли файл уже (нет ли его имени в `Log_ETL_Runs`). Это позволяет безопасно перезапустить пакет, если он упал до архивации."

---
