# **Инициализация (Initial Load) и последующая инкрементальная загрузка через CDC**.

---

## **Проблема в двух словах:**

1.  У вас есть **источник** (например, `SalesDB`) с включенным CDC на нужных таблицах.
2.  У вас есть **пустая целевая база** (`DWH`).
3.  CDC в источнике хранит изменения только последние 3 дня.
4.  Как **впервые заполнить целевую базу** (Initial Load) и при этом **не потерять изменения**, которые произошли во время этого заполнения?
5.  И как потом **продолжать загружать только новые изменения** (Incremental Load) с правильной точки?

---

## **Ключевое непонимание:** Разделение на два РАЗНЫХ процесса

CDC в SSIS — это **два разных сценария**, которые реализуются **разными компонентами**:

1.  **Начальная загрузка (Initial Load)** — заполнение целевой таблицы **полным снимком данных** на текущий момент. Для этого **НЕ используется CDC Source**.
2.  **Инкрементальная загрузка (Incremental Load)** — загрузка **только изменений**, произошедших после начальной загрузки. Для этого **используется CDC Source**.

**А теперь главное:** **CDC State (метка)** — это **точка во времени, ДО которой изменения мы уже загрузили.**

---

## **Пошаговый сценарий с нуля:**

### **ШАГ 0: Подготовка**
*   В источнике (`SalesDB`) включен CDC для таблицы `Sales`.
*   В источнике есть таблица `cdc.Sales_CT` (таблица изменений).
*   CDC хранит изменения последние 3 дня (но это неважно для логики).
*   Целевая таблица `DWH.dbo.Sales` — **пустая**.

---

### **ШАГ 1: Начальная загрузка (Initial Load) — БЕЗ CDC**

**Цель:** Скопировать ВСЕ текущие данные из источника в цель.

1.  **Создаем пакет `Initial_Load.dtsx`.**
2.  **Data Flow Task:**
    *   Источник: **OLE DB Source** → `SELECT * FROM SalesDB.dbo.Sales`
    *   Назначение: **OLE DB Destination** → `DWH.dbo.Sales`
3.  **Запускаем этот пакет.** Теперь целевая таблица содержит **полный снимок** на момент `T1`.

**Проблема:** Пока мы копировали данные (допустим, операция длилась 2 часа), в источнике могли произойти изменения (INSERT/UPDATE/DELETE). Эти изменения:
*   Попали в таблицу CDC (`cdc.Sales_CT`)
*   **НЕ попали в нашу начальную загрузку** (т.к. мы копировали статичный снимок на момент начала копирования)

**Вопрос:** Как не потерять эти изменения?

---

### **ШАГ 2: Определение точки начала CDC (Mark Load Start)**

**Логика:** Нам нужно запомнить **момент времени НЕПОСРЕДСТВЕННО ПЕРЕД началом начальной загрузки**. Тогда позже мы сможем загрузить все изменения, которые произошли **ПОСЛЕ** этого момента.

1.  **Модифицируем пакет `Initial_Load.dtsx`:**
    *   **ДО** Data Flow Task добавляем **CDC Control Task**.
    *   Настраиваем его: **Operation = "Mark initial load start"**.

2.  **Что происходит при запуске:**
    *   CDC Control Task **получает текущую отметку времени** с сервера-источника (чезов `sys.fn_cdc_get_max_lsn()` или аналогичную функцию).
    *   **Записывает эту метку (LSN)** в таблицу состояний CDC (например, `cdc_states`).
    *   **Сохраняет эту метку в переменную пакета** `User::CDC_State`.
    
    **Представьте:** Вы смотрите на часы прямо перед началом копирования и записываете: "Начали копировать в 10:00:00". Это `CDC_State`.

3.  **Потом выполняется Data Flow Task** (начальная загрузка), которая копирует данные.

---

### **ШАГ 3: Загрузка изменений, произошедших ВО ВРЕМЯ начальной загрузки**

После того как начальная загрузка завершена, у нас есть:
*   Целевая таблица с данными на примерный момент `T1` (начало копирования)
*   Метка `CDC_State = LSN_T1` (точное время начала)

Теперь нам нужно "догнать" изменения, которые произошли в источнике **МЕЖДУ `T1` и `T2`** (где `T2` — момент завершения начальной загрузки).

1.  **Создаем пакет `Incremental_Load.dtsx`** (который будет работать всегда).
2.  **Control Flow:**
    *   **CDC Control Task** (Operation = "Get processing range") — берет из таблицы состояний последнюю сохраненную метку (`LSN_T1`) и **определяет диапазон изменений, которые нужно обработать**.
    *   **Data Flow Task:**
        *   Источник: **CDC Source** → Указываем режим работы и диапазон LSN
        *   Преобразования для обработки вставок/обновлений/удалений
        *   Назначение: **CDC Splitter** + соответствующие Destination
    *   **CDC Control Task** (Operation = "Mark processed range") — обновляет метку в таблице состояний на **конец обработанного диапазона**.

3.  **Запускаем `Incremental_Load.dtsx` сразу после `Initial_Load.dtsx`**:
    *   Он возьмет метку `LSN_T1` (начало начальной загрузки)
    *   Загрузит ВСЕ изменения, которые произошли с момента `LSN_T1` до **текущего максимального LSN** в источнике
    *   Обновит метку состояния

**Результат:** Теперь целевая таблица **синхронизирована** с источником на текущий момент!

---

## **А что с ограничением "3 дня хранения CDC"?**

Это **критически важно** для начальной загрузки!

**Сценарий катастрофы:**
1.  Начальная загрузка огромной таблицы заняла **4 дня**.
2.  CDC в источнике хранит изменения только **3 дня**.
3.  К моменту завершения начальной загрузки, **самые ранние изменения (первые дни загрузки) уже удалены из CDC**.
4.  Инкрементальная загрузка **не сможет "догнать" эти изменения** → **потеря данных!**

**Решение:**
1.  **Разбить начальную загрузку на части** (по датам, по диапазонам ключей).
2.  **Для каждой части:**
    *   Получить метку CDC (Mark load start)
    *   Загрузить часть данных
    *   Сразу же загрузить изменения по этой части (пока они еще в CDC)
    *   Обновить метку
3.  **Или:** Увеличить срок хранения CDC на время начальной загрузки.

---

## **Практический пример с временной шкалой:**

```
Время   | Действие
--------|---------------------------------------------------
10:00   | Запуск Initial_Load.dtsx
10:00:01| CDC Control Task: Mark load start → CDC_State = LSN_A
10:00:02| Начало копирования данных (2 млн строк)
12:00   | В источнике: Пользователь изменяет строку ID=100 (это изменение попадает в cdc.Sales_CT с LSN_B, где B > A)
13:00   | Завершение копирования данных
        | Теперь в цели есть данные на ~10:00, но без изменения строки ID=100
13:01   | Запуск Incremental_Load.dtsx
13:01   | CDC Control Task: Get processing range → находит CDC_State = LSN_A
13:01   | CDC Source: Запрашивает все изменения с LSN > A до текущего максимума
        | Находит изменение строки ID=100 (LSN_B) и применяет его к цели
13:02   | CDC Control Task: Mark processed range → обновляет CDC_State на LSN_C (текущий максимум)
```

Теперь целевая таблица **полностью актуальна**.

---

## **Где хранится CDC_State и как она выглядит?**

Метка CDC — это **не дата/время**, а **LSN (Log Sequence Number)** — внутренний идентификатор транзакции в журнале транзакций SQL Server.

*   **Таблица состояний:** По умолчанию `[dbo].[cdc_states]` в целевой БД (или в БД, указанной в CDC Control Task).
*   **Структура:** `state_name`, `state` (бинарное значение LSN), `last_update`.
*   **Переменная пакета:** `User::CDC_State` содержит **это бинарное значение**.

---

## **Ответ на ваш конкретный вопрос:**

> "как мы вычислим метку, с которой надо продолжать дальше?"

**Вы ее не вычисляете — вы ее ЗАПОМНИТЕ (запишете) перед начальной загрузкой.**

1.  **Перед начальной загрузкой:** Выполняете `Mark initial load start` → получаете `CDC_State = LSN_X`.
2.  **Выполняете начальную загрузку.**
3.  **После начальной загрузки:** Запускаете инкрементальную загрузку, которая:
    *   Берет сохраненную `LSN_X`
    *   Загружает все изменения с `LSN > X`
    *   Обновляет состояние на новое значение

**Если CDC пустой или срок хранения истек:**
*   **Проверка:** Можно выполнить `sys.fn_cdc_get_min_lsn('Sales')` и сравнить с вашей сохраненной меткой.
*   **Если ваша метка старше минимального доступного LSN** → **данные потеряны**, нужно делать **полную повторную загрузку**.

---

# Что произойдет, если после начальной загрузки вы забудете запустить инкрементальную загрузку, а запустите ее только через неделю, при этом CDC хранит данные только 3 дня?
