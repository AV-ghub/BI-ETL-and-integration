# **Инициализация (Initial Load) и последующая инкрементальная загрузка через CDC**.

---

## **Проблема в двух словах:**

1.  У вас есть **источник** (например, `SalesDB`) с включенным CDC на нужных таблицах.
2.  У вас есть **пустая целевая база** (`DWH`).
3.  CDC в источнике хранит изменения только последние 3 дня.
4.  Как **впервые заполнить целевую базу** (Initial Load) и при этом **не потерять изменения**, которые произошли во время этого заполнения?
5.  И как потом **продолжать загружать только новые изменения** (Incremental Load) с правильной точки?

---

## **Ключевое непонимание:** Разделение на два РАЗНЫХ процесса

CDC в SSIS — это **два разных сценария**, которые реализуются **разными компонентами**:

1.  **Начальная загрузка (Initial Load)** — заполнение целевой таблицы **полным снимком данных** на текущий момент. Для этого **НЕ используется CDC Source**.
2.  **Инкрементальная загрузка (Incremental Load)** — загрузка **только изменений**, произошедших после начальной загрузки. Для этого **используется CDC Source**.

**А теперь главное:** **CDC State (метка)** — это **точка во времени, ДО которой изменения мы уже загрузили.**

---

## **Пошаговый сценарий с нуля:**

### **ШАГ 0: Подготовка**
*   В источнике (`SalesDB`) включен CDC для таблицы `Sales`.
*   В источнике есть таблица `cdc.Sales_CT` (таблица изменений).
*   CDC хранит изменения последние 3 дня (но это неважно для логики).
*   Целевая таблица `DWH.dbo.Sales` — **пустая**.

---

### **ШАГ 1: Начальная загрузка (Initial Load) — БЕЗ CDC**

**Цель:** Скопировать ВСЕ текущие данные из источника в цель.

1.  **Создаем пакет `Initial_Load.dtsx`.**
2.  **Data Flow Task:**
    *   Источник: **OLE DB Source** → `SELECT * FROM SalesDB.dbo.Sales`
    *   Назначение: **OLE DB Destination** → `DWH.dbo.Sales`
3.  **Запускаем этот пакет.** Теперь целевая таблица содержит **полный снимок** на момент `T1`.

**Проблема:** Пока мы копировали данные (допустим, операция длилась 2 часа), в источнике могли произойти изменения (INSERT/UPDATE/DELETE). Эти изменения:
*   Попали в таблицу CDC (`cdc.Sales_CT`)
*   **НЕ попали в нашу начальную загрузку** (т.к. мы копировали статичный снимок на момент начала копирования)

**Вопрос:** Как не потерять эти изменения?

---

### **ШАГ 2: Определение точки начала CDC (Mark Load Start)**

**Логика:** Нам нужно запомнить **момент времени НЕПОСРЕДСТВЕННО ПЕРЕД началом начальной загрузки**. Тогда позже мы сможем загрузить все изменения, которые произошли **ПОСЛЕ** этого момента.

1.  **Модифицируем пакет `Initial_Load.dtsx`:**
    *   **ДО** Data Flow Task добавляем **CDC Control Task**.
    *   Настраиваем его: **Operation = "Mark initial load start"**.

2.  **Что происходит при запуске:**
    *   CDC Control Task **получает текущую отметку времени** с сервера-источника (чезов `sys.fn_cdc_get_max_lsn()` или аналогичную функцию).
    *   **Записывает эту метку (LSN)** в таблицу состояний CDC (например, `cdc_states`).
    *   **Сохраняет эту метку в переменную пакета** `User::CDC_State`.
    
    **Представьте:** Вы смотрите на часы прямо перед началом копирования и записываете: "Начали копировать в 10:00:00". Это `CDC_State`.

3.  **Потом выполняется Data Flow Task** (начальная загрузка), которая копирует данные.

---

### **ШАГ 3: Загрузка изменений, произошедших ВО ВРЕМЯ начальной загрузки**

После того как начальная загрузка завершена, у нас есть:
*   Целевая таблица с данными на примерный момент `T1` (начало копирования)
*   Метка `CDC_State = LSN_T1` (точное время начала)

Теперь нам нужно "догнать" изменения, которые произошли в источнике **МЕЖДУ `T1` и `T2`** (где `T2` — момент завершения начальной загрузки).

1.  **Создаем пакет `Incremental_Load.dtsx`** (который будет работать всегда).
2.  **Control Flow:**
    *   **CDC Control Task** (Operation = "Get processing range") — берет из таблицы состояний последнюю сохраненную метку (`LSN_T1`) и **определяет диапазон изменений, которые нужно обработать**.
    *   **Data Flow Task:**
        *   Источник: **CDC Source** → Указываем режим работы и диапазон LSN
        *   Преобразования для обработки вставок/обновлений/удалений
        *   Назначение: **CDC Splitter** + соответствующие Destination
    *   **CDC Control Task** (Operation = "Mark processed range") — обновляет метку в таблице состояний на **конец обработанного диапазона**.

3.  **Запускаем `Incremental_Load.dtsx` сразу после `Initial_Load.dtsx`**:
    *   Он возьмет метку `LSN_T1` (начало начальной загрузки)
    *   Загрузит ВСЕ изменения, которые произошли с момента `LSN_T1` до **текущего максимального LSN** в источнике
    *   Обновит метку состояния

**Результат:** Теперь целевая таблица **синхронизирована** с источником на текущий момент!

---

## **А что с ограничением "3 дня хранения CDC"?**

Это **критически важно** для начальной загрузки!

**Сценарий катастрофы:**
1.  Начальная загрузка огромной таблицы заняла **4 дня**.
2.  CDC в источнике хранит изменения только **3 дня**.
3.  К моменту завершения начальной загрузки, **самые ранние изменения (первые дни загрузки) уже удалены из CDC**.
4.  Инкрементальная загрузка **не сможет "догнать" эти изменения** → **потеря данных!**

**Решение:**
1.  **Разбить начальную загрузку на части** (по датам, по диапазонам ключей).
2.  **Для каждой части:**
    *   Получить метку CDC (Mark load start)
    *   Загрузить часть данных
    *   Сразу же загрузить изменения по этой части (пока они еще в CDC)
    *   Обновить метку
3.  **Или:** Увеличить срок хранения CDC на время начальной загрузки.

---

## **Практический пример с временной шкалой:**

```
Время   | Действие
--------|---------------------------------------------------
10:00   | Запуск Initial_Load.dtsx
10:00:01| CDC Control Task: Mark load start → CDC_State = LSN_A
10:00:02| Начало копирования данных (2 млн строк)
12:00   | В источнике: Пользователь изменяет строку ID=100 (это изменение попадает в cdc.Sales_CT с LSN_B, где B > A)
13:00   | Завершение копирования данных
        | Теперь в цели есть данные на ~10:00, но без изменения строки ID=100
13:01   | Запуск Incremental_Load.dtsx
13:01   | CDC Control Task: Get processing range → находит CDC_State = LSN_A
13:01   | CDC Source: Запрашивает все изменения с LSN > A до текущего максимума
        | Находит изменение строки ID=100 (LSN_B) и применяет его к цели
13:02   | CDC Control Task: Mark processed range → обновляет CDC_State на LSN_C (текущий максимум)
```

Теперь целевая таблица **полностью актуальна**.

---

## **Где хранится CDC_State и как она выглядит?**

Метка CDC — это **не дата/время**, а **LSN (Log Sequence Number)** — внутренний идентификатор транзакции в журнале транзакций SQL Server.

*   **Таблица состояний:** По умолчанию `[dbo].[cdc_states]` в целевой БД (или в БД, указанной в CDC Control Task).
*   **Структура:** `state_name`, `state` (бинарное значение LSN), `last_update`.
*   **Переменная пакета:** `User::CDC_State` содержит **это бинарное значение**.

---

## **Ответ на ваш конкретный вопрос:**

> "как мы вычислим метку, с которой надо продолжать дальше?"

**Вы ее не вычисляете — вы ее ЗАПОМНИТЕ (запишете) перед начальной загрузкой.**

1.  **Перед начальной загрузкой:** Выполняете `Mark initial load start` → получаете `CDC_State = LSN_X`.
2.  **Выполняете начальную загрузку.**
3.  **После начальной загрузки:** Запускаете инкрементальную загрузку, которая:
    *   Берет сохраненную `LSN_X`
    *   Загружает все изменения с `LSN > X`
    *   Обновляет состояние на новое значение

**Если CDC пустой или срок хранения истек:**
*   **Проверка:** Можно выполнить `sys.fn_cdc_get_min_lsn('Sales')` и сравнить с вашей сохраненной меткой.
*   **Если ваша метка старше минимального доступного LSN** → **данные потеряны**, нужно делать **полную повторную загрузку**.

---

# Что произойдет, если после начальной загрузки вы забудете запустить инкрементальную загрузку, а запустите ее только через неделю, при этом CDC хранит данные только 3 дня?

---

## **Сценарий: "Забыли про инкрементальную загрузку"**

**Исходные условия:**
- Начальная загрузка завершилась в `Пн, 10:00` (CDC State = `LSN_Пн_10:00`)
- CDC хранит изменения **3 дня**
- Инкрементальную загрузку забыли запустить
- Вспомнили и запустили только **в Чт, 10:00** (через 3 дня)

---

### **Что произойдет в момент запуска инкрементальной загрузки в Чт, 10:00:**

1.  **CDC Control Task (Get processing range):**
    - Достает из таблицы состояний сохраненную метку: `LSN_Пн_10:00`
    - Запрашивает у SQL Server текущий максимальный LSN через `sys.fn_cdc_get_max_lsn()`

2.  **SQL Server проверяет, какие изменения еще доступны:**
    - Выполняет `sys.fn_cdc_get_min_lsn('schema_table')` → получает **минимальный доступный LSN**
    - **Поскольку CDC хранит 3 дня, минимальный доступный LSN будет примерно = `LSN_Пн_10:00` (или немного позже)**
    - Максимальный LSN = `LSN_Чт_10:00`

3.  **Ключевой момент:**
    - Если ваш сохраненный `LSN_Пн_10:00` **СТАРШЕ** минимального доступного LSN → **ошибка!**
    - SQL Server не может предоставить изменения с `LSN_Пн_10:00`, потому что они уже удалены
    - **Но:** Так как прошло ровно 3 дня, есть шанс, что изменения с `LSN_Пн_10:00` еще доступны (граничный случай)

4.  **Предположим, что изменения с Пн еще доступны:**
    - CDC Source запросит изменения с `LSN_Пн_10:00` до `LSN_Чт_10:00`
    - **НО!** Изменения, которые произошли в **первый день после начальной загрузки** (с Пн 10:00 до Вт 10:00) уже удалены из CDC!
    - CDC Source получит только изменения **за последние 2 дня** (со Вт 10:00 до Чт 10:00)

---

## **Визуализация потери данных:**

```
Время     | CDC данные в источнике          | Что загрузится
----------|--------------------------------|-------------------
Пн 09:59 | Уже удалено (4 дня назад)       | 
Пн 10:00 | [НАЧАЛЬНАЯ ЗАГРУЗКА] CDC State = LSN_A |
Пн 10:01 | Изменение 1 (LSN_B)             | ❌ УДАЛЕНО из CDC
Пн 12:00 | Изменение 2 (LSN_C)             | ❌ УДАЛЕНО из CDC
Вт 08:00 | Изменение 3 (LSN_D)             | ❌ УДАЛЕНО из CDC
Вт 10:01 | Изменение 4 (LSN_E)             | ✓ ДОСТУПНО (3 дня)
Ср 14:00 | Изменение 5 (LSN_F)             | ✓ ДОСТУПНО (2 дня)
Чт 09:59 | Изменение 6 (LSN_G)             | ✓ ДОСТУПНО (1 день)
Чт 10:00 | [ЗАПУСК ИНКРЕМЕНТАЛЬНОЙ ЗАГРУЗКИ] |
```

**Результат:** Из 6 изменений, произошедших после начальной загрузки, загрузятся только **3 последних** (E, F, G). Изменения B, C, D будут **безвозвратно потеряны**.

---

## **Как SSIS обрабатывает эту ситуацию?**

### **Вариант 1: Ошибка "The requested LSN is less than the minimum available LSN"**
CDC Source упадет с ошибкой, если запрошенный начальный LSN уже недоступен.

### **Вариант 2: Частичная загрузка**
Если начальный LSN еще доступен, но часть диапазона уже удалена — будет загружено только то, что осталось. **Без предупреждений!**

**Это страшно именно потому, что:**
- Пакет выполнится **успешно** (зеленая галочка)
- В логах будет указано, сколько строк обработано
- **Никаких ошибок о потерянных данных не будет!**
- Вы узнаете о проблеме только когда бизнес спросит: "А где данные за понедельник?"

---

## **Как защититься от этого?**

### **1. Мониторинг сроков хранения CDC:**
```sql
-- Проверить, не устарела ли наша метка
DECLARE @min_lsn binary(10), @stored_lsn binary(10)

-- Минимальный доступный LSN
SELECT @min_lsn = sys.fn_cdc_get_min_lsn('Sales')

-- Наш сохраненный LSN
SELECT @stored_lsn = state FROM cdc_states WHERE state_name = 'Sales_CDC'

-- Если наш LSN старше минимального -> данные потеряны
IF @stored_lsn < @min_lsn
    RAISERROR('CDC data loss detected! Stored LSN is older than available min LSN.', 16, 1)
```

### **2. Регулярные проверки в пакете:**
Добавить **Script Task** перед CDC Source, который проверяет разницу между сохраненным LSN и текущим минимальным LSN.

### **3. Увеличить срок хранения CDC:**
Для production-систем, где инкрементальная загрузка критична, устанавливайте срок хранения CDC **не менее 7-14 дней**, даже если загрузка ежедневная.

### **4. Аварийный сценарий:**
```sql
-- Если обнаружили потерю данных
-- 1. Увеличить срок хранения CDC немедленно
EXEC sp_cdc_change_job @job_type = 'cleanup', @retention = 10080 -- минут (7 дней)

-- 2. Сделать полную повторную загрузку:
--    а) Удалить запись из cdc_states
--    б) Выполнить Initial Load заново
--    в) Начать инкрементальную загрузку с новой метки
```

---

## **Практический совет для реальных проектов:**

**Всегда настраивайте CDC с запасом:**
- Ежедневная загрузка → хранить 7 дней
- Еженедельная загрузка → хранить 14 дней
- Плюс учитывайте время на устранение сбоев

**И самое главное — мониторьте этот запас:**
```sql
-- Ежедневная проверка
SELECT 
    DATEDIFF(HOUR, 
        sys.fn_cdc_map_lsn_to_time(@stored_lsn), -- время вашего последнего LSN
        sys.fn_cdc_map_lsn_to_time(@min_lsn)     -- время самого старого доступного LSN
    ) AS HoursOfDataLossRisk
-- Если меньше 24 часов до потери данных -> алерт!
```

---

# Что будет, если инкрементальная загрузка запускается ежедневно, но один раз зависла на 12 часов, а потом была перезапущена? Потеряются ли данные при сроке хранения CDC = 3 дня?

---

## **Сценарий: Инкрементальная загрузка зависла и была перезапущена**

**Детали:**
- Ежедневная загрузка в 03:00
- CDC хранит 3 дня (72 часа)
- **Пн 03:00** — загрузка успешна, обработаны изменения с Вс 03:00 до Пн 03:00
- **Вт 03:00** — загрузка **зависла**, работает 12 часов
- **Вт 15:00** — администратор убивает процесс, видит, что загрузка не завершилась
- **Вт 15:01** — перезапуск загрузки вручную

---

## **Что происходит с CDC State (меткой)?**

### **Ключевой момент:** 
**CDC State обновляется ТОЛЬКО при успешном завершении CDC Control Task "Mark processed range"!**

Если загрузка зависла и была убита:
1. **CDC State НЕ обновилась** — осталась равной `LSN_Пн_03:00`
2. **Часть данных могла уже загрузиться** (если зависла на позднем этапе)
3. **Но метка не сдвинулась**

---

## **При перезапуске в 15:00:**

### **1. CDC Control Task "Get processing range":**
- Достает из таблицы состояний метку: `LSN_Пн_03:00`
- Определяет диапазон для обработки: `LSN_Пн_03:00` → `текущий_максимальный_LSN`

### **2. Проблема:** 
**Диапазон огромный!** Нужно обработать изменения:
- **Пн 03:00 - Вт 03:00** (уже должны были быть обработаны вчера)
- **Вт 03:00 - Вт 15:00** (новые изменения за сегодня + время зависания)

### **3. Риск:**
- **Дублирование данных:** Часть изменений из `Пн 03:00 - Вт 03:00` уже могла быть загружена до зависания
- **Производительность:** Обработка 36-часового диапазона вместо 24-часового
- **Но потери данных НЕ будет** (если CDC хранит 3 дня)

---

## **Как правильно обработать такой сценарий?**

### **Паттерн 1: "Идемпотентная" загрузка (рекомендуется)**
Если ваша загрузка идемпотентна (повторная обработка тех же данных не создает дубли), то просто перезапускаете. CDC Source выдаст те же изменения, но ваша логика должна их корректно обработать.

**Пример для UPSERT (вставка или обновление):**
```sql
-- Вместо простого INSERT используете MERGE
MERGE TargetTable AS t
USING (SELECT * FROM #CDC_Changes) AS s
ON t.ID = s.ID
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT ...
-- Идентичные изменения обработаются корректно
```

### **Паттерн 2: Проверка "что уже загружено"**
Перед загрузкой проверяете, не загружены ли уже данные за этот диапазон:

```sql
-- В Script Task перед CDC Source
DECLARE @LastLoadedDate DATETIME
SELECT @LastLoadedDate = MAX(LoadDate) FROM TargetTable

-- Если у нас уже есть данные за сегодня, возможно, нужно пропустить старый диапазон
```

### **Паттерн 3: Использование Checkpoints в SSIS**
Настроив Control Points, можно заставить пакет перезапуститься **с места сбоя**, а не с начала.

---

## **А что если зависание было дольше, чем срок хранения CDC?**

**Вот тут реальная опасность!**

Сценарий:
- Зависла загрузка **Пн 03:00**
- Обнаружили и перезапустили только **Чт 18:00** (через 87 часов)
- CDC хранит **72 часа** (3 дня)

**Расчет:**
- Последний успешный запуск: `LSN_Вс_03:00`
- Минимальный доступный LSN в Чт 18:00: `LSN_Пн_18:00` (72 часа назад)
- Наша метка `LSN_Вс_03:00` **уже удалена из CDC**!

**Результат:** 
1. CDC Source упадет с ошибкой "requested LSN is less than min LSN"
2. **Или** (в зависимости от настроек) попробует начать с минимального доступного LSN
3. **Потеря данных за 39 часов!** (Вс 03:00 - Пн 18:00)

---

## **Практические рекомендации для продакшена:**

### **1. Мониторинг длительности выполнения:**
```sql
-- Алерт, если загрузка идет дольше N часов
IF (SELECT DATEDIFF(HOUR, start_time, GETDATE()) 
    FROM [SSISDB].[catalog].[executions] 
    WHERE status = 2 AND package_name = 'YourPackage') > 6
BEGIN
    -- Отправка алерта, попытка graceful stop
    EXEC [catalog].[stop_operation] @operation_id
END
```

### **2. Настройка timeout в SQL Agent Job:**
```
В шаге Job: 
- Advanced → "Quit the job reporting failure" → 4 hours
```

### **3. Регулярная проверка "отставания":**
```sql
-- Ежедневный отчет: на сколько часов отстает наш CDC State
SELECT 
    state_name,
    DATEDIFF(HOUR, 
        sys.fn_cdc_map_lsn_to_time(state),  -- время последней метки
        GETDATE()                           -- текущее время
    ) AS HoursBehind,
    CASE 
        WHEN DATEDIFF(HOUR, sys.fn_cdc_map_lsn_to_time(state), GETDATE()) > 48 
        THEN 'WARNING: More than 2 days behind!'
        WHEN DATEDIFF(HOUR, sys.fn_cdc_map_lsn_to_time(state), GETDATE()) > 24 
        THEN 'CAUTION: More than 1 day behind'
        ELSE 'OK'
    END AS Status
FROM cdc_states
```

### **4. Автоматический перезапуск с проверкой:**
```powershell
# Псевдокод для скрипта перезапуска
$lastSuccessTime = Get-LastSuccessfulRunTime
$cdcRetentionHours = 72
$hoursSinceSuccess = (Get-Date) - $lastSuccessTime

if ($hoursSinceSuccess.TotalHours -gt $cdcRetentionHours - 12) {
    # Опасно! Мало запаса. Нужна полная перезагрузка
    Write-Output "CDC data loss risk! Need FULL reload."
    Start-FullReloadProcess
} else {
    # Еще есть запас, можно безопасно перезапустить
    Write-Output "Safe to restart incremental load"
    Restart-SSISPackage
}
```

---

## **Ответ на ваш вопрос:**

**Да, при перезапуске будет перечитан диапазон с момента последней успешной загрузки, и если:**
1. **CDC еще хранит данные с того момента** (срок хранения не истек)
2. **Ваша загрузка идемпотентна** (корректно обрабатывает дубли)
3. **Производительность позволяет** обработать увеличенный диапазон

**То все действительно наладится.**

**Но если любое из этих условий не выполняется — будут проблемы.**

---

**Итоговая мысль:** CDC-загрузка в SSIS — это **очень надежный механизм, но с четкими границами надежности**. Эти границы задаются **сроком хранения CDC** и **регулярностью выполнения**. Выход за эти границы требует специальных процедур восстановления (часто — полной перезагрузки данных).
